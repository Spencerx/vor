---
layout: sensor
---		

<script src="threejs/three.min.js"></script>

<script src="threejs/TrackballControls.js"></script>

<script src="threejs/STLLoader.js"></script>

<script src="threejs/Detector.js"></script>
<script src="threejs/stats.js"></script>

<script>

	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

	var container, stats;

	var camera, controls, scene, renderer, explode;

	var cross;

	var animationTime = 500; //ms
	var animationDistance = 50;
	var offsets = {
		x: -50,
		z: -10,
		y: 0
	};


	init();
	animate();


	function init() {

		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );
		camera.position.z = -200;

		controls = new THREE.TrackballControls( camera );

		controls.rotateSpeed = 5.0;
		controls.zoomSpeed = 5;
		controls.panSpeed = 2;

		controls.noZoom = false;
		controls.noPan = false;

		controls.staticMoving = true;
		controls.dynamicDampingFactor = 0.3;

		scene = new THREE.Scene();

		scene.add( camera );

		// lights

		var lights = [
			{
				x: 400,
				y: 1000,
				z: 1000,
				color: 0xffffff,
				intensity: 1.0,
			},
			{
				x: -400,
				y: -200,
				z: 1000,
				color: 0xffffff,
				intensity: 0.4,
			},
		];

		lights.forEach(function(light) {
			var dirLight = new THREE.DirectionalLight(light.color);
			dirLight.position.set(light.x, light.y, light.z).normalize();

			camera.add( dirLight );
			camera.add( dirLight.target );
		});

		var caseColor = 0x645862;
		var motionSensorColor = 0xffffff;
		var methaneSensorColor = 0xf0f0ff;

		var imgPath = 'img/';
		var imgFormat = '.png';
		var urls = [
			imgPath + 'wall_with_logo' + imgFormat, imgPath + 'wall_with_logo' + imgFormat,
			imgPath + 'ceiling' + imgFormat, imgPath + 'floor' + imgFormat,
			imgPath + 'wall_with_logo' + imgFormat, imgPath + 'wall_with_logo' + imgFormat
		];

		var loader = new THREE.STLLoader();
		var textureCube = THREE.ImageUtils.loadTextureCube( urls );

		var sensorPath = '../vor-3d-models/3d-iot-case-models/bathroom-sensor-case-';

		var models = [
			{ // half of the actual box
				path: sensorPath+'left.stl',
				color: caseColor,
			},
			{ // half of the actual box
				path: sensorPath+'right.stl',
				color: caseColor,
			},
			{ // the "nose"
				path: sensorPath+'methane-sensor.stl',
				color: methaneSensorColor,
				envMap: textureCube,
			},
			{ // the "eyes"
				path: sensorPath+'right-motion-sensor.stl',
				color: motionSensorColor,
			},
			{
				path: sensorPath+'left-motion-sensor.stl',
				color: motionSensorColor,
			},
			// {
			// 	path: '../vor-3d-models/3d-iot-component-models/arduino-yun-mini.stl',
			// 	color: motionSensorColor
			// },
		];

		models.forEach(function(model, index) {
			loader.load(model.path , function ( geometry ) {

				geometry.computeVertexNormals();

				var opts = {
					color: model.color
				};

				if (model.envMap) {
					opts.envMap = model.envMap
				}

				var material = new THREE.MeshPhongMaterial(opts);

				var mesh = new THREE.Mesh( geometry, material );
				mesh.position.x = offsets.x;
				mesh.position.y = offsets.y;
				mesh.position.z = offsets.z;
				scene.add( mesh );

				model.mesh = mesh;

			});
		});

		// separating the halves

		explode = {
			'models': [ models[1], models[4] ],
			'separation': 0,
			'animationStart': 0,
			'animationDirection': 0,
			'exploded': false,
		};

		var shader = THREE.ShaderLib[ "cube" ];
		shader.uniforms[ "tCube" ].value = textureCube;

		var material = new THREE.ShaderMaterial( {

			fragmentShader: shader.fragmentShader,
			vertexShader: shader.vertexShader,
			uniforms: shader.uniforms,
			depthWrite: false,
			side: THREE.BackSide

		} ),

		mesh = new THREE.Mesh( new THREE.BoxGeometry( 1000, 1000, 1000 ), material );
		scene.add( mesh );

		// renderer

		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );

		container = document.createElement( 'div' );
		document.body.appendChild( container );
		container.appendChild( renderer.domElement );

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );

		//

		window.addEventListener( 'resize', onWindowResize, false );
		window.addEventListener( 'click', onClick, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		controls.handleResize();

	}

	function separateBy(models, n) {
		models.forEach(function(it) {
			it.mesh.position.x = offsets.x - n;
			it.mesh.position.y = offsets.y - n;
		});
	}

	function onClick() {
		var now = Date.now();
		if (now - explode.animationStart < animationTime) {
			// previous animation still running, ignore
			return;
		}

		explode.animationStart = now;
		if (explode.exploded) {
			// close
			explode.animationDirection = -1;
		} else {
			// open
			explode.animationDirection = 1;
		}
	}

	function updateExplode(explode) {
		var now = Date.now();
		var timeDiff = now - explode.animationStart;

		if (timeDiff > animationTime) {
			if (explode.animationDirection === 0) {
				return;
			}
			explode.exploded = explode.animationDirection > 0;
			explode.animationDirection = 0;

			if (!explode.exploded) {
				// make sure there's no extra spacing
				separateBy(explode.models, 0);
			}
			return;
		}

		var separation = -1 * explode.animationDirection * timeDiff * (animationDistance/animationTime);
		if (explode.exploded) {
			separation -= animationDistance;
		}

		explode.separation = separation;
		separateBy(explode.models, explode.separation);
	}

	function animate() {

		requestAnimationFrame( animate );

		updateExplode(explode);
		controls.update();
		renderer.render( scene, camera );

		stats.update();

	}

</script>
